/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the terms of the LICENSE file distributed with this project.
 */
import * as tslib_1 from "tslib";
import * as classNames from "classnames";
import * as moment from "moment";
import * as React from "react";
import { AbstractComponent, InputGroup, Keys, Popover, Position, Utils, } from "@blueprintjs/core";
import { fromDateToMoment, fromMomentToDate, isMomentInRange, isMomentNull, isMomentValidAndInRange, momentToString, stringToMoment, } from "./common/dateUtils";
import { DATEINPUT_WARN_DEPRECATED_OPEN_ON_FOCUS, DATEINPUT_WARN_DEPRECATED_POPOVER_POSITION } from "./common/errors";
import { DatePicker } from "./datePicker";
import { getDefaultMaxDate, getDefaultMinDate } from "./datePickerCore";
import { DateTimePicker } from "./dateTimePicker";
var DateInput = (function (_super) {
    tslib_1.__extends(DateInput, _super);
    function DateInput(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.inputRef = null;
        _this.contentRef = null;
        _this.lastElementInPopover = null;
        _this.getDateString = function (value) {
            if (isMomentNull(value)) {
                return "";
            }
            if (value.isValid()) {
                if (_this.isMomentInRange(value)) {
                    return momentToString(value, _this.props.format, _this.props.locale);
                }
                else {
                    return _this.props.outOfRangeMessage;
                }
            }
            return _this.props.invalidDateMessage;
        };
        _this.handleClosePopover = function (e) {
            var _a = _this.props.popoverProps, popoverProps = _a === void 0 ? {} : _a;
            Utils.safeInvoke(popoverProps.onClose, e);
            _this.setState({ isOpen: false });
        };
        _this.handleDateChange = function (date, hasUserManuallySelectedDate, didSubmitWithEnter) {
            if (didSubmitWithEnter === void 0) { didSubmitWithEnter = false; }
            var prevMomentDate = _this.state.value;
            var momentDate = fromDateToMoment(date);
            // this change handler was triggered by a change in month, day, or (if
            // enabled) time. for UX purposes, we want to close the popover only if
            // the user explicitly clicked a day within the current month.
            var isOpen = !hasUserManuallySelectedDate ||
                _this.hasMonthChanged(prevMomentDate, momentDate) ||
                _this.hasTimeChanged(prevMomentDate, momentDate) ||
                !_this.props.closeOnSelection;
            // if selecting a date via click or Tab, the input will already be
            // blurred by now, so sync isInputFocused to false. if selecting via
            // Enter, setting isInputFocused to false won't do anything by itself,
            // plus we want the field to retain focus anyway.
            // (note: spelling out the ternary explicitly reads more clearly.)
            var isInputFocused = didSubmitWithEnter ? true : false;
            if (_this.props.value === undefined) {
                _this.setState({ isInputFocused: isInputFocused, isOpen: isOpen, value: momentDate, valueString: _this.getDateString(momentDate) });
            }
            else {
                _this.setState({ isInputFocused: isInputFocused, isOpen: isOpen });
            }
            Utils.safeInvoke(_this.props.onChange, date === null ? null : fromMomentToDate(momentDate));
        };
        _this.handleInputFocus = function (e) {
            var valueString;
            if (isMomentNull(_this.state.value)) {
                valueString = "";
            }
            else {
                valueString = momentToString(_this.state.value, _this.props.format, _this.props.locale);
            }
            if (_this.props.openOnFocus) {
                _this.setState({ isInputFocused: true, isOpen: true, valueString: valueString });
            }
            else {
                _this.setState({ isInputFocused: true, valueString: valueString });
            }
            _this.safeInvokeInputProp("onFocus", e);
        };
        _this.handleInputClick = function (e) {
            if (_this.props.openOnFocus) {
                e.stopPropagation();
            }
            _this.safeInvokeInputProp("onClick", e);
        };
        _this.handleInputChange = function (e) {
            var valueString = e.target.value;
            var value = _this.createMoment(valueString);
            if (value.isValid() && _this.isMomentInRange(value)) {
                if (_this.props.value === undefined) {
                    _this.setState({ value: value, valueString: valueString });
                }
                else {
                    _this.setState({ valueString: valueString });
                }
                Utils.safeInvoke(_this.props.onChange, fromMomentToDate(value));
            }
            else {
                if (valueString.length === 0) {
                    Utils.safeInvoke(_this.props.onChange, null);
                }
                _this.setState({ valueString: valueString });
            }
            _this.safeInvokeInputProp("onChange", e);
        };
        _this.handleInputBlur = function (e) {
            var valueString = _this.state.valueString;
            var value = _this.createMoment(valueString);
            if (valueString.length > 0 &&
                valueString !== _this.getDateString(_this.state.value) &&
                (!value.isValid() || !_this.isMomentInRange(value))) {
                if (_this.props.value === undefined) {
                    _this.setState({ isInputFocused: false, value: value, valueString: null });
                }
                else {
                    _this.setState({ isInputFocused: false });
                }
                if (!value.isValid()) {
                    Utils.safeInvoke(_this.props.onError, new Date(undefined));
                }
                else if (!_this.isMomentInRange(value)) {
                    Utils.safeInvoke(_this.props.onError, fromMomentToDate(value));
                }
                else {
                    Utils.safeInvoke(_this.props.onChange, fromMomentToDate(value));
                }
            }
            else {
                if (valueString.length === 0) {
                    _this.setState({ isInputFocused: false, value: moment(null), valueString: null });
                }
                else {
                    _this.setState({ isInputFocused: false });
                }
            }
            _this.registerPopoverBlurHandler();
            _this.safeInvokeInputProp("onBlur", e);
        };
        _this.handleInputKeyDown = function (e) {
            if (e.which === Keys.ENTER) {
                var nextValue = _this.createMoment(_this.state.valueString);
                var nextDate = fromMomentToDate(nextValue);
                _this.handleDateChange(nextDate, true, true);
            }
            else if (e.which === Keys.TAB && e.shiftKey) {
                // close the popover if focus will move to the previous element on
                // the page. tabbing forward should *not* close the popover, because
                // focus will be moving into the popover itself.
                _this.setState({ isOpen: false });
            }
            else if (e.which === Keys.ESCAPE) {
                _this.setState({ isOpen: false });
                _this.inputRef.blur();
            }
            _this.safeInvokeInputProp("onKeyDown", e);
        };
        // focus DOM event listener (not React event)
        _this.handlePopoverBlur = function (e) {
            var relatedTarget = e.relatedTarget;
            if (relatedTarget == null || !_this.contentRef.contains(relatedTarget)) {
                _this.handleClosePopover();
            }
        };
        _this.registerPopoverBlurHandler = function () {
            if (_this.contentRef != null) {
                // Popover contents are well structured, but the selector will need
                // to be updated if more focusable components are added in the future
                var tabbableElements = _this.contentRef.querySelectorAll("input, [tabindex]:not([tabindex='-1'])");
                var numOfElements = tabbableElements.length;
                if (numOfElements > 0) {
                    // Keep track of the last focusable element in popover and add
                    // a blur handler, so that when:
                    // * user tabs to the next element, popover closes
                    // * focus moves to element within popover, popover stays open
                    var lastElement = tabbableElements[numOfElements - 1];
                    if (_this.lastElementInPopover !== lastElement) {
                        _this.unregisterPopoverBlurHandler();
                        _this.lastElementInPopover = lastElement;
                        _this.lastElementInPopover.addEventListener("blur", _this.handlePopoverBlur);
                    }
                }
            }
        };
        _this.unregisterPopoverBlurHandler = function () {
            if (_this.lastElementInPopover != null) {
                _this.lastElementInPopover.removeEventListener("blur", _this.handlePopoverBlur);
            }
        };
        _this.setInputRef = function (el) {
            _this.inputRef = el;
            var _a = _this.props.inputProps, inputProps = _a === void 0 ? {} : _a;
            Utils.safeInvoke(inputProps.inputRef, el);
        };
        _this.setContentRef = function (el) {
            _this.contentRef = el;
        };
        var defaultValue = _this.props.defaultValue ? fromDateToMoment(_this.props.defaultValue) : moment(null);
        _this.state = {
            isInputFocused: false,
            isOpen: false,
            value: _this.props.value !== undefined ? fromDateToMoment(_this.props.value) : defaultValue,
            valueString: null,
        };
        return _this;
    }
    DateInput.prototype.componentWillUnmount = function () {
        _super.prototype.componentWillUnmount.call(this);
        this.unregisterPopoverBlurHandler();
    };
    DateInput.prototype.render = function () {
        var _this = this;
        var _a = this.state, value = _a.value, valueString = _a.valueString;
        var dateString = this.state.isInputFocused ? valueString : this.getDateString(value);
        var date = this.state.isInputFocused ? this.createMoment(valueString) : value;
        var dateValue = this.isMomentValidAndInRange(value) ? fromMomentToDate(value) : null;
        var dayPickerProps = tslib_1.__assign({}, this.props.dayPickerProps, { 
            // dom elements for the updated month is not available when
            // onMonthChange is called. setTimeout is necessary to wait
            // for the updated month to be rendered
            onMonthChange: function (month) {
                Utils.safeInvoke(_this.props.dayPickerProps.onMonthChange, month);
                _this.setTimeout(_this.registerPopoverBlurHandler);
            } });
        var popoverContent = this.props.timePrecision === undefined ? (React.createElement(DatePicker, tslib_1.__assign({}, this.props, { dayPickerProps: dayPickerProps, onChange: this.handleDateChange, value: dateValue }))) : (React.createElement(DateTimePicker, { canClearSelection: this.props.canClearSelection, onChange: this.handleDateChange, value: dateValue, datePickerProps: this.props, timePickerProps: tslib_1.__assign({}, this.props.timePickerProps, { precision: this.props.timePrecision }) }));
        var wrappedPopoverContent = React.createElement("div", { ref: this.setContentRef }, popoverContent);
        // assign default empty object here to prevent mutation
        var _b = this.props, _c = _b.inputProps, inputProps = _c === void 0 ? {} : _c, _d = _b.popoverProps, popoverProps = _d === void 0 ? {} : _d, format = _b.format;
        // exclude ref (comes from HTMLInputProps typings, not InputGroup)
        var ref = inputProps.ref, htmlInputProps = tslib_1.__rest(inputProps, ["ref"]);
        var inputClasses = classNames({
            "pt-intent-danger": !(this.isMomentValidAndInRange(date) || isMomentNull(date) || dateString === ""),
        }, inputProps.className);
        var popoverClassName = classNames(popoverProps.className, this.props.className);
        var placeholder = typeof format === "string" ? format : format.placeholder;
        return (React.createElement(Popover, tslib_1.__assign({ inline: true, isOpen: this.state.isOpen && !this.props.disabled, position: this.props.popoverPosition }, popoverProps, { autoFocus: false, className: popoverClassName, content: wrappedPopoverContent, enforceFocus: false, onClose: this.handleClosePopover, popoverClassName: classNames("pt-dateinput-popover", popoverProps.popoverClassName) }),
            React.createElement(InputGroup, tslib_1.__assign({ autoComplete: "off", placeholder: placeholder, rightElement: this.props.rightElement }, htmlInputProps, { className: inputClasses, disabled: this.props.disabled, inputRef: this.setInputRef, type: "text", onBlur: this.handleInputBlur, onChange: this.handleInputChange, onClick: this.handleInputClick, onFocus: this.handleInputFocus, onKeyDown: this.handleInputKeyDown, value: dateString }))));
    };
    DateInput.prototype.componentWillReceiveProps = function (nextProps) {
        _super.prototype.componentWillReceiveProps.call(this, nextProps);
        if (nextProps.value !== this.props.value) {
            this.setState({ value: fromDateToMoment(nextProps.value) });
        }
    };
    DateInput.prototype.validateProps = function (props) {
        if (props.popoverPosition !== DateInput.defaultProps.popoverPosition) {
            console.warn(DATEINPUT_WARN_DEPRECATED_POPOVER_POSITION);
        }
        if (props.openOnFocus !== DateInput.defaultProps.openOnFocus) {
            console.warn(DATEINPUT_WARN_DEPRECATED_OPEN_ON_FOCUS);
        }
    };
    DateInput.prototype.createMoment = function (valueString) {
        // Locale here used for parsing, does not set the locale on the moment itself
        return stringToMoment(valueString, this.props.format, this.props.locale);
    };
    DateInput.prototype.isMomentValidAndInRange = function (value) {
        return isMomentValidAndInRange(value, this.props.minDate, this.props.maxDate);
    };
    DateInput.prototype.isMomentInRange = function (value) {
        return isMomentInRange(value, this.props.minDate, this.props.maxDate);
    };
    DateInput.prototype.shouldCheckForDateChanges = function (prevMomentDate, nextMomentDate) {
        return nextMomentDate != null && !isMomentNull(prevMomentDate) && prevMomentDate.isValid();
    };
    DateInput.prototype.hasMonthChanged = function (prevMomentDate, nextMomentDate) {
        return (this.shouldCheckForDateChanges(prevMomentDate, nextMomentDate) &&
            nextMomentDate.month() !== prevMomentDate.month());
    };
    DateInput.prototype.hasTimeChanged = function (prevMomentDate, nextMomentDate) {
        return (this.shouldCheckForDateChanges(prevMomentDate, nextMomentDate) &&
            this.props.timePrecision != null &&
            (nextMomentDate.hours() !== prevMomentDate.hours() ||
                nextMomentDate.minutes() !== prevMomentDate.minutes() ||
                nextMomentDate.seconds() !== prevMomentDate.seconds() ||
                nextMomentDate.milliseconds() !== prevMomentDate.milliseconds()));
    };
    /** safe wrapper around invoking input props event handler (prop defaults to undefined) */
    DateInput.prototype.safeInvokeInputProp = function (name, e) {
        var _a = this.props.inputProps, inputProps = _a === void 0 ? {} : _a;
        Utils.safeInvoke(inputProps[name], e);
    };
    DateInput.defaultProps = {
        closeOnSelection: true,
        dayPickerProps: {},
        disabled: false,
        format: "YYYY-MM-DD",
        invalidDateMessage: "Invalid date",
        maxDate: getDefaultMaxDate(),
        minDate: getDefaultMinDate(),
        openOnFocus: true,
        outOfRangeMessage: "Out of range",
        popoverPosition: Position.BOTTOM,
        reverseMonthAndYearMenus: false,
        timePickerProps: {},
    };
    DateInput.displayName = "Blueprint.DateInput";
    return DateInput;
}(AbstractComponent));
export { DateInput };
